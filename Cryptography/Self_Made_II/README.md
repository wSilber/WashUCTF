# Self Made II

## Challenge Description

Professory Ning taught me why my self made encryption algorithm was insecure. Now I know confuse and diffuse... confuse and diffuse... confuse and diffuse... 

97 230 204 230 115 178 101 82 86 147 146 147 100 138 128 73 39 203 41 14 83 13 190 59 242 143 217 120

## Solution

In this challenge the user is given a Python file with a definition of a self made encryption algorithm and several helper methods. The algorithm itself features an n-round feistel network where half of the plaintext is XORed with randomly generated keys and then substituted according to an S-box. There are many steps to reversing this algorithm.

### Reversing the Algorithm

Given the feistel network the reversing algorithm will just be running the same feistel network in reverse. Thus the reverse algorithm will contain the same algorithm. All that is needed is to find the keys and the inverse S-box.

### Finding all keys

It can be seen on line 22 that the seed is given with the program. This means that all keys generated by the `randint()` function are not completely random and are deterministic. Every time the program is run the same keys will be generated. The keys need to be the same length of the text it is XORed with. Thus a length of half of the flag given (14) will be used to generate keys since each key will be XORed with half of the plaintext for each feistel round. Since the amount of keys is not known, a guess of 1000 keys were generated and stored.

### Finding the Inverse sbox

The last part needed is to find the inverse of the sbox provided to undo the substitution. For this it is important to understand how the substitution method works. For every byte in the string provided as input, the byte will be split into two nibbles. The higher nibble will be the row and the lower nibble will be the column in the sbox. Thus the inverse S-box will be the inverse of this. This can be done by hand, but it is recommended to make a program for this. The sbox used is also the sbox used in AES, Rijndael S-box, thus the inverse can be found online.

### Reversing the flag

With all of the keys and inverse sbox generated, the flag can now be reversed. By providing the keys in reverse, one can decrypt the key starting at 1000 iterations and checking if the result contains "flag{". If the flag is not found then decrease the amount of keys and feistel iterations. Keep decreasing the iterations until the flag is found. It can be found with 433 iterations.

### Flag: flag{V35y_S3cur3_41G0_54827}
